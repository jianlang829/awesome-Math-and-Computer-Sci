**参考：[https://blog.csdn.net/m0_61840987/article/details/145023835](https://blog.csdn.net/m0_61840987/article/details/145023835)**

这篇文章是一篇**非常清晰、实用的入门教程**，用 C 语言实现**辛普森法则（Simpson’s Rule）**来计算**定积分**。下面我会用“讲人话”的方式，把文章的重点、易错点和可以升级的地方一口气讲透，方便你以后直接拿来用或教别人。

---

### 1. 辛普森法则到底在干什么？
一句话：  
**“用一串抛物线去逼近曲线，再把抛物线下的面积加起来。”**

- 梯形法则用的是直线，辛普森用的是**二次曲线**，所以同样分段数下精度更高。
- 必须**偶数个小区间**（n 为偶数），因为每两段拼成一条抛物线。

---

### 2. 公式怎么来的？（只看图也能懂）
把 [a,b] 等分成 n 份，每份宽  
h = (b−a)/n  

然后“三点一组”画抛物线，面积公式就是高中抛物线面积：  
**Sᵢ = (h/3)·[f(xᵢ) + 4f(xᵢ₊₁) + f(xᵢ₊₂)]**

整条曲线面积就是把所有小组面积累加，合并同类项后得到总公式：  
**Integral ≈ (h/3)·[f(x₀) + 4Σ奇 + 2Σ偶 + f(xₙ)]**

代码里那几行 `sum += 4*…` 和 `sum += 2*…` 就是在做这件事。

---

### 3. 代码逐行“翻译”
| 代码片段 | 人类语言 |
|---|---|
| `if (n % 2 != 0) n++;` | 用户给奇数？我偷偷加 1，别报错。 |
| `double h = (b - a) / n;` | 每小段宽度。 |
| `sum = func(a) + func(b);` | 先算两头。 |
| 第一个 for | 奇数下标统统×4。 |
| 第二个 for | 偶数下标统统×2，但两头已算过，所以到 `n-1` 为止。 |
| `return sum * h / 3;` | 套公式，收工。 |

---

### 4. 运行结果验证
∫₀¹ x² dx = 1/3 ≈ 0.333333  
n=6 时程序打出 0.333333，**完美吻合**，因为 **x² 的三次导数是 0**，辛普森对 ≤3 次多项式是**精确解**，误差理论为 0。

---

### 5. 想再“玩花”的？给你 3 个升级路线
1. **自适应辛普森**  
   不停二分区间，估计误差，达到指定精度就停。10 行代码就能写，精度翻倍。

2. **任意函数接口**  
   把 `f()` 做成函数指针，甚至用 `dlopen` 动态加载用户写的 `.so`，变成“迷你 MATLAB”。

3. **OpenMP 并行版**  
   奇偶项拆开分别做 reduction，百万段毫秒级。

---

### 6. 常见坑提醒
| 坑 | 现象 | 解决 |
|---|---|---|
| 用户给奇数 n | 结果突然变差 | 代码已自动加 1，但最好提示一句。 |
| 区间反向 a>b | 得负数 | 加一句 `if (a>b) { swap(&a,&b); sign=-1; }` |
| 大 n 时累加误差 | 结果漂移 | 用 Kahan 求和或 `long double`。 |

---

### 7. 一句话总结
**“辛普森 = 抛物线拟合 + 三点面积公式，C 语言 30 行就能搞定，平滑函数下精度秒梯形。”**

把这段代码保存成 `simpson.c`，以后任何定积分，改两行函数定义就能直接跑，堪称“数值积分小瑞士军刀”。

使用说明：

------------------------------------------------

1. 编译：  
   `g++ simpson.cpp -lm -fopenmp -O2 -o simpson`
2. 运行：  
   `./simpson`  
